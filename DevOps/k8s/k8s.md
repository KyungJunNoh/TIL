# K8s(Kubernetes)
##### K8s는 컨테이너화된 워크로드 및 서비스를 관리하기 위한 이식 가능하고 확장 가능한 오픈 소스 플랫폼으로, 선언적 구성과 자동화를 모두 용이하게 합니다.
##### Kubernetes라는 이름은 조타수 또는 조종사를 의미하는 그리스어에서 유래되었습니다. K8s는 "K"와 "s" 사이의 8개 문자를 세어 나온 약어입니다.
##### Google은 2014년에 Kubernetes 프로젝트를 오픈 소스로 공개했습니다.

<br>

### K8s가 유용한 이유와 역사

<img src="./img/container_evolution.svg">

##### **기존 배포 방식**: 초기에는 물리적 서버에서 애플리케이션을 실행했습니다. 물리적 서버에서 애플리케이션에 대한 리소스 경계를 정의할 방법이 없었으며 이로 인해 리소스를 할당 문제가 발생했습니다.

##### **가상화 배포 시대**: 솔루션으로 가상화가 도입되었습니다. 이를 통해 단일 물리적 서버의 CPU에서 열 가상 머신(VM)을 실행할 수 있습니다. 가상화를 사용하면 애플리케이션을 VM 간에 격리할 수 있으며 한 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없기 때문에 보안 수준을 제공합니다.

##### 가상화를 사용하면 물리적 서버에서 리소스를 더 잘 활용할 수 있고 응용 프로그램을 쉽게 추가하거나 업데이트할 수 있고 하드웨어 비용을 줄이는 등의 작업을 수행할 수 있기 때문에 확장성이 향상됩니다. 가상화를 사용하면 일련의 물리적 리소스를 일회용 가상 머신의 클러스터로 나타낼 수 있습니다.

##### 각 VM은 가상화된 하드웨어 위에서 자체 운영 체제를 포함한 모든 구성 요소를 실행하는 전체 시스템입니다.

##### **컨테이너 배포 시대**: 컨테이너는 VM과 유사하지만 애플리케이션 간에 운영 체제(OS)를 공유하기 위해 격리 속성을 완화했습니다. 따라서 컨테이너는 경량으로 간주됩니다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 공유, 메모리, 프로세스 공간 등이 있습니다. 기본 인프라에서 분리되므로 클라우드 및 OS 배포 간에 이식 가능합니다.

##### 컨테이너는 다음과 같은 추가 이점을 제공하기 때문에 대중화되었습니다.

- ##### 민첩한 애플리케이션 생성 및 배포: VM 이미지 사용에 비해 컨테이너 이미지 생성의 용이성과 효율성이 향상되었습니다.
- ##### 지속적인 개발, 통합 및 배포: 빠르고 효율적인 롤백으로 안정적이고 빈번한 컨테이너 이미지 빌드 및 배포를 제공합니다(이미지 불변성으로 인해).
- ##### 개발 및 운영의 관심사 분리: 배포 시간이 아닌 빌드/릴리스 시간에 애플리케이션 컨테이너 이미지를 생성하여 인프라에서 애플리케이션을 분리합니다.
- ##### 관찰 가능성: OS 수준 정보 및 메트릭을 표시할 뿐만 아니라 애플리케이션 상태 및 기타 신호도 표시합니다.
- ##### 개발, 테스트 및 생산 전반에 걸친 환경적 일관성: 클라우드에서와 마찬가지로 노트북에서도 동일하게 실행됩니다.
- ##### 클라우드 및 OS 배포 이식성: Ubuntu, RHEL, CoreOS, 온프레미스, 주요 퍼블릭 클라우드 및 기타 모든 곳에서 실행됩니다.
- ##### 애플리케이션 중심 관리: 가상 하드웨어에서 OS를 실행하는 것에서 논리적 리소스를 사용하여 OS에서 애플리케이션을 실행하는 것으로 추상화 수준을 높입니다.
- ##### 느슨하게 결합되고, 분산되고, 탄력적이고, 자유로운 마이크로 서비스: 애플리케이션은 더 작고 독립적인 조각으로 나뉘며 하나의 큰 단일 목적 시스템에서 실행되는 모놀리식 스택이 아니라 동적으로 배포 및 관리될 수 있습니다.
- ##### 리소스 격리: 예측 가능한 애플리케이션 성능.
- ##### 자원 활용: 고효율 및 밀도.

<br>

### Kubernetes가 필요한 이유

##### Kubernets는 분산 시스템을 탄력적으로 실행할 수 있는 프레임워크를 제공합니다. 애플리케이션의 확장 및 장애 조치를 처리하고 배포 패턴 등을 제공합니다. 

- ###### **서비스 검색 및 부하 분산** Kubernetes는 DNS 이름 또는 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. 컨테이너에 대한 트래픽이 많으면 Kubernetes는 안정적인 배포를 위해 부하를 분산하고 네트워크 트래픽을 분산할 수 있습니다.
- ##### <span style="color:red"> **스토리지 오케스트레이션** Kubernetes를 사용하면 로컬 스토리지, 퍼블릭 클라우드 공급자 등과 같은 선택한 스토리지 시스템을 자동으로 마운트할 수 있습니다.</span>
- ##### <span style="color:red"> **자동화된 롤아웃 및 롤백** Kubernetes를 사용하여 배포된 컨테이너의 원하는 상태를 설명할 수 있으며 제어된 속도로 실제 상태를 원하는 상태로 변경할 수 있습니다. 예를 들어 Kubernetes를 자동화하여 배포를 위한 새 컨테이너를 만들고 기존 컨테이너를 제거하고 모든 리소스를 새 컨테이너에 채택할 수 있습니다.</span>
- ##### <span style="color:red"> **자동 빈 패킹** Kubernetes에 컨테이너화된 작업을 실행하는 데 사용할 수 있는 노드 클러스터를 제공합니다. 각 컨테이너에 필요한 CPU 및 메모리(RAM)의 양을 Kubernetes에 알립니다. Kubernetes는 리소스를 최대한 활용하기 위해 컨테이너를 노드에 맞출 수 있습니다.</span>
- ##### **자가 치유** Kubernetes는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하고, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 종료하고, 제공할 준비가 될 때까지 클라이언트에 알리지 않습니다.
- ##### **암호 및 구성 관리** Kubernetes를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 민감한 정보를 저장하고 관리할 수 있습니다. 컨테이너 이미지를 다시 빌드하지 않고 스택 구성에서 비밀을 노출하지 않고 비밀 및 애플리케이션 구성을 배포하고 업데이트할 수 있습니다.




